
## TCP 和 UDP 的区别
- 相同点：TCP 和 UDP 都在传输层，作用都是在程序之间传输数据，数据可以是文本、图片和视频
- TCP：传输控制协议，面向连接 可靠稳定协议，传输速度慢，稳定可靠，因为有三次握手
- UDP：用户实时协议、无连接、不可靠协议，传输速度较快，不保证数据的完整性，适应于对实时性要求较高的场景（写信）
## UDP 如何实现可靠的传输
如果想要在UDP的基础上实现可靠的数据传输，可以采用RUDP（Reliable UDP）协议。
RUDP是在UDP之上添加一些可靠性机制来实现数据传输的可靠性，主要包括以下特性：
- 数据包确认和重传：发送方在发送数据包后等待接收方的确认，如果超时未收到确认，会重传数据包。
- 序列号和顺序性：为每个数据包添加序列号，确保接收方按照正确的顺序接收数据包。
- 拥塞控制：根据网络状况动态调整发送速率，避免网络拥塞。
- 流量控制：限制发送方发送数据的速率，避免接收方无法处理过多的数据。
- 超时重传：设定超时时间，如果在超时时间内未收到确认，进行数据包的重传。
实现RUDP需要在UDP的基础上添加这些额外的机制。通常，开发人员可以在应用层实现这些功能，或者使用现有的可靠传输库或框架，如KCP、ENet等。这些库提供了可靠的UDP传输功能，简化了开发者的工作。
总的来说，RUDP通过在UDP之上增加一些机制来提供数据传输的可靠性和顺序性，使得在一些对数据可靠性要求比较高的场景下能够更好地满足需求。

## TCP 三次握手（TCP 工作原理）
三次握手是建立连接的过程。当客户端像服务端发起连接时，会先发一包连接请求数据并询问服务端，
能否与你建立连接，这包数据称为 SYN 包。如果服务端同意连接，则回复一包 SYN+ACK 包，客户端收到
之后回复一包ACK包，连接建立，因为这个过程中互相发送三包数据，所以称之为三次握手。
## 为什么不是两次握手
这是为了防止因为已失效的请求报文，突然又传到服务器引起错误。
假如采用两次握手建立连接，客户端发送SYN向服务端建立连接，因为某些未知的原因，并没有到达服务器，
在中间某个网络节点产生了滞留，为了建立连接 客户端会重发SYN包，这次的数据包正常送达，服务端回复
SYN+ACK后建立连接，但是第一包数据阻塞的网络节点突然恢复，第一包SYN包又送达到服务端，这时服务端
会误认为是客户端又发起了一个新的连接，从而在两次握手之后，进入等待数据状态，服务端会认为是两个连接，
而客户端认为是一个连接，造成了状态不一致，如果在三次握手的情况下，服务端收不到最后的ACK包的话，
自然不会认为连接建立成功，所以三次握手本质上来说，就是为了解决网络信道不可靠的问题，为了能够在
不可靠的信道上，建立起可靠的连接，经过三次握手之后，客户端和服务端都进入了数据传输状态。
## 三次握手的SYN是什么
在 TCP 协议的三次握手过程中，SYN 和 ACK 是两个重要的标志位，用于建立连接的确认和同步。
SYN（Synchronize）：
在 TCP 三次握手的第一步中，客户端（Client）发送一个带有 SYN 标志位的数据包给服务端（Server），表示客户端请求建立连接。这个数据包表明客户端希望与服务器建立连接。
在这个阶段，客户端会选择一个初始的序列号（Sequence Number），用来对数据进行编号。
ACK（Acknowledgment）：
在 TCP 三次握手的第二步中，服务端接收到客户端发送的带有 SYN 标志位的数据包后，会向客户端发送一个带有 SYN 和 ACK 标志位的数据包，表示服务端接受了客户端的连接请求，并且服务端也请求建立连接。
在这个阶段，服务端会选择一个自己的初始序列号，并且确认客户端的初始序列号。
在 TCP 三次握手过程中，SYN 和 ACK 标志位的作用是相互确认对方的请求和自身的接受，以确保双方通信的同步和连接的建立。
## 三次握手一定安全吗
三次握手也存在一些隐患，最主要的是SYN攻击，
攻击者发送大量伪造的连接请求（SYN 包）给服务器，但不发送 ACK 包完成连接建立，导致服务器资源被占用，无法建立正常连接。
如何防御？
- 启用 SYN Cookies 可以防御 SYN 攻击。在 SYN 攻击发生时，服务器会根据客户端发送的 SYN 包计算出一个 Cookie 值，将该 Cookie 值发送给客户端。只有客户端收到 Cookie 值后才能继续建立连接。这样可以防止服务器资源被耗尽。
- 可以设置最大连接数限制，当连接数达到上限时拒绝新的连接请求，以保护服务器资源免受 SYN 攻击的影响。
- 连接超时处理：可以设置连接超时时间，当连接在一定时间内没有完成握手，自动关闭连接，释放资源。

## 四次挥手
第一步：客户端发送一个带有 FIN（Finish）标志位的数据包给服务器，表示客户端不再发送数据，但仍接收数据。自己进入终止等待1状态
第二步：服务端接收到客户端的 FIN 数据包后，发送一个 ACK 数据包给客户端，确认收到了客户端的关闭请求。表示自己进入了关闭等待状态，客户端进入终止等待2状态，服务端此时还可以发送未发送的数据，而客户端还可以接收数据，待服务端发送完数据之后，进入第三次挥手。
第三步：服务端在完成自己所有的发送后，发送一个带有 FIN 标志位的数据包给客户端，表示服务端也准备关闭连接。
第四步：客户端接收到服务端的 FIN 数据包后，发送一个 ACK 数据包给服务端，确认收到了关闭请求。此时客户端和服务端的连接完全关闭。
TCP四次挥手的具体步骤：
Client -> Server：FIN（客户端发送关闭连接请求）终止等待1状态
Server -> Client：ACK（服务端确认收到关闭请求）服务端进入关闭等待状态，客户端进入终止等待2状态
Server -> Client：FIN（服务端发送关闭连接请求）最后确认状态
Client -> Server：ACK（客户端确认收到关闭请求）超时等待状态

## 为什么客户端要在TIME_WAIT状态等待一段时间
为什么客户端需要等待超时时间？这是为了保证对方已收到ACK包，因为假设客户端发送完最后一包ACK包
后就释放了连接，一旦ACK包在网络中丢失，服务端将一直停留在最后确认状态，如果客户端发送最后一包
ACK包后，等待一段时间，这时服务端因为没有收到ACK包，会重发FIN包，客户端会响应这个FIN包，
重发ACK包并刷新超时时间，这个机制跟三次握手一样，也是为了保证在不可靠的网络链路中，进行可靠的
连接断开确认。

## 在四次挥手中，为什么需要两个 FIN 数据包
在 TCP 的四次挥手过程中，为什么需要两个 FIN 数据包是因为 TCP 是全双工通信的协议，允许通信双方的数据流独立地关闭。下面解释为什么需要两个 FIN 数据包：
- 半关闭连接：
当一方（比如客户端）决定不再向另一方（服务端）发送数据，但仍希望接收数据时，会发送一个带有 FIN 标志位的数据包，表示该方不再发送数据。
- 全双工通信：
TCP 是全双工通信的协议，双方可以独立地发送和接收数据。因此，当一方发送了一个 FIN 数据包表示自己不再发送数据时，另一方仍然可以继续向前发送数据。
- 关闭确认：
接收到对方的 FIN 数据包后，表示对方不再发送数据，但仍允许接收数据。接收到 FIN 数据包的一方会发送一个 ACK 数据包作为确认，表示收到了关闭请求。
- 最终关闭连接：
当双方都发送了一个 FIN 数据包并收到了对方的 ACK 确认后，表示双方都已经做好了关闭准备。此时，双方都知道对方不再发送数据，可以安全地关闭连接。
因此，在四次挥手过程中，第一次发送 FIN 数据包的一方表明自己不再发送数据，但仍然能够接收数据；而第二次发送 FIN 数据包的一方则表示自己不再发送数据，同时也不再接收数据，从而完成连接的关闭。这种设计确保了连接的安全关闭和数据传输的完整性。

## 如果server端没有收到第三次ack，但是收到了client端发送的数据，server端会怎么处理
总的来说，服务器端在未收到第三次 ACK 但收到客户端数据的情况下，会尝试通过超时重传机制来重新发送 ACK 数据包，保持连接状态，并在一定的机制下处理连接的释放和资源释放。TCP 协议的设计考虑了网络不稳定和数据包丢失的情况，因此有相应的机制来处理这类情况以确保连接的可靠性和稳定性。
下面是一般情况下服务器端可能会采取的处理步骤：
超时重传：
如果服务器端没有收到第三次 ACK，但仍然收到了客户端发送的数据，服务器端会启动超时重传机制，尝试重新发送第四次挥手的 ACK 数据包。
保持连接状态：
在等待 ACK 数据包的过程中，服务器端会保持连接状态，继续等待客户端的响应或数据。
最大重传次数：
TCP 协议通常会设置最大重传次数的限制，如果超过最大重传次数仍未收到 ACK，服务器端可能会认为连接已经失效，并进行连接释放。
资源释放：
如果服务器端在一定时间内未收到客户端的 ACK，可能会释放连接占用的资源，关闭连接。
异常处理：
需要注意，这种情况可能会引发异常情况，需要服务器端进行相应的异常处理，比如记录日志、尝试重传等。

## TCP如何进行拥塞控制？拥塞控制如何判断发生拥塞？
TCP（Transmission Control Protocol） 是一种面向连接的、可靠的传输协议，拥塞控制是 TCP 中重要的机制之一，用于避免网络拥塞并维持网络的稳定性。TCP 进行拥塞控制的方式如下：

TCP 拥塞控制机制：
慢启动（Slow Start）：
初始时，TCP 发送方会以较慢的速率增加传输窗口大小，每当收到一个确认时，窗口大小就会加倍，直到达到一个慢启动阈值。
拥塞避免（Congestion Avoidance）：
一旦传输窗口大小达到慢启动阈值，TCP 发送方会进入拥塞避免阶段，每轮传输窗口只增加1个单位，以避免快速增加引起的网络拥塞。
快重传（Fast Retransmit）：
如果接收方收到乱序的数据包或检测到丢失的数据包，会立即向发送方发送重复确认，触发发送方快速重传丢失的数据包。
快恢复（Fast Recovery）：
在发生丢包后，TCP 发送方会进入快恢复状态，继续以慢启动阈值大小的一半增加传输窗口，而不是回到慢启动状态。
判断拥塞发生的方式：
超时重传：
如果发送方在超时时间内没有收到确认，将重新发送数据，认为这是网络发生拥塞的迹象。
丢包率：
如果接收方频繁收到乱序数据或需要进行快速重传，可能是网络发生拥塞，丢包率上升。
拥塞窗口调整：
TCP 发送方通过监视传输窗口的大小和响应时间，判断网络的状态和拥塞程度，调整传输速率来适应网络状况。
接收方通知：
如果接收方收到过多的数据，可能会向发送方发送窗口更新信息，减缓发送方的速率，避免网络拥塞。
拥塞控制是 TCP 协议中非常重要的机制，通过动态调整传输速率和窗口大小，TCP 能够在网络拥塞时减少数据包的丢失并维持网络的稳定性。通过监控网络状况和适时调整发送速率，TCP 能够有效地应对网络拥塞。
## 讲一下TCP协议中滑动窗口
滑动窗口是 TCP 协议中用于流量控制和可靠传输的重要机制，用于管理数据包的发送和接收。

工作原理：发送方和接收方各自维护一个滑动窗口，用于控制发送和接收数据包的速率。发送方根据接收方的窗口大小来确定发送数据包的数量，接收方根据自身的处理能力和缓冲区状态来控制数据包的接收。通过滑动窗口机制，发送方和接收方可以动态调整数据包的传输速率，实现流量控制和可靠传输。
作用：
流量控制：滑动窗口机制可以确保发送方不会发送过多的数据包，避免接收方处理不过来的情况。
可靠传输：滑动窗口机制可以确保数据包按正确的顺序传输，接收方可以根据窗口的大小来确认已接收的数据包，确保数据的可靠传输。
滑动窗口是 TCP 协议中重要的机制之一，通过动态调整窗口大小来实现流量控制和可靠传输，提高网络传输的效率和可靠性。
## TCP粘包和拆包
TCP 粘包（TCP packet sticking） 和 拆包（TCP packet fragmentation） 是 TCP 通信中常见的问题，涉及到数据在传输过程中的处理。

TCP 粘包：
TCP 粘包指的是发送方发送两个独立的数据包，但接收方收到时却合并成一个数据包的情况。这可能发生在发送方连续发送数据包时，接收方一次性接收到多个数据包，导致粘在一起。
TCP 粘包可能是由于底层 TCP 协议的数据传输机制造成的，TCP 是面向流的传输协议，数据是以流的形式传输的，没有消息边界，接收方需要自行判断数据的边界。
TCP 拆包：
TCP 拆包是指一个完整的数据包被拆分成多个部分到达接收方。这可能发生在发送方发送一个大数据包，但网络传输过程中被拆分成多个小数据包发送，接收方需要将这些小数据包重新组装成完整的数据包。
TCP 拆包也是由于 TCP 的面向流特性造成的，接收方需要处理数据包的组装。

解决TCP 粘包和拆包的方法：
1. 消息边界：
在数据包中加入消息边界，例如在数据包中添加特殊的分隔符或固定长度的消息头，以便接收方能够正确判断数据包的边界。
2. 消息长度：
在数据包中包含消息长度信息，接收方根据消息长度来正确接收和处理数据包。
3. 消息序号：
在数据包中包含序号信息，接收方根据序号来正确接收和排序数据包。
## 2. TCP 和UDP 用一个端口发送信息是否会出现冲突
不会出现冲突
TCP 和 UDP 是完全独立的协议，它们的端口号**互不影响**。例如：
- **53端口**：DNS 服务同时使用 TCP（区域传输）和 UDP（普通查询）。
- **同一个端口号**（如 5000）可以同时运行一个 TCP 服务和一个 UDP 服务，不会冲突。