3. 事务并发问题（3个）
事务AB同时操作一个表
并发事务问题可分为三个：
- 脏读：一个事务读到另一个事务还没有提交的数据
    
    A 事务操作update，但是还没有提交，B事务读取了更新的数据
    
- 不可重复读：一个事务先后读取一个数据，但两次读取的数据不同，
    
    A事务查询操作，B事务更新操作并提交，A执行查询语句，发现数据不同
    
- 幻读：一个事务按照条件查询数据时，没有对应的数据行，但是在插入数据时，又发现这行数据已经存在，好像出现了“幻影”
    
    按照条件执行没有发现数据行
4. 事务隔离级别（四个）
事务隔离级别就是为了解决并发事务问题

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| --- | --- | --- | --- |
| Read uncommitted（读未提交） | ✅ | ✅ | ✅ |
| Read committed（读已提交，oracle默认） | ❌ | ✅ | ✅ |
| Repeatable Read(Mysql默认)（可重复读） | ❌ | ❌ | ✅ |
| Serializable（可串行化） | ❌ | ❌ | ❌ |

从上到下 隔离级别越来越高，Serializable 性能最差

如何查看事务的隔离级别

select @@transaction_isolation;
![alt text](<Pic/Untitled.png>)

设置事务的隔离级别

session:只针对当前客户端窗口有效

global: 针对所有客户端的窗口有效

set session transaction isolation level Read uncommitted;

set session transaction isolation level REPEATABLE READ;

读未提交 存在脏读数据问题

![alt text](<Pic/Untitled1.png>)

设置：读已提交

没有脏读

![alt text](<Pic/Untitled2.png>)

同一个sql语句在一个事务中得到的结果不一样

![alt text](<Pic/Untitled3.png>)

set session transaction isolation level REPEATABLE READ;

同一个sql语句在同一个事务中得到的数据相同，可重复读数据。

![alt text](<Pic/Untitled4.png>)
幻读：查的时候没有，但是插入的时候报错

![alt text](<Pic/Untitled5.png>)

串行化：一次只允许一个事务操作，只有当A事务提交完成之后，B事务才能执行。

![alt text](<Pic/Untitled6.png>)

注意：事务隔离级别越高，数据越安全，但是性能越低。